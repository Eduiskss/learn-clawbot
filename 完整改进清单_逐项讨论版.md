# Conversation Agent å®Œæ•´æ”¹è¿›æ¸…å•

> **ç›®æ ‡**: è¾¾åˆ°/è¶…è¶ŠMoltbotçš„Agentæ™ºèƒ½æ°´å¹³  
> **ä½¿ç”¨æ–¹å¼**: é€ä¸€è®¨è®ºæ¯ä¸ªæ”¹è¿›ç‚¹ï¼Œæ·±å…¥åˆ†æå¹¶å®æ–½  
> **ç‰ˆæœ¬**: v1.0 | æ—¥æœŸ: 2026-01-28

---

## ğŸ“‹ æ”¹è¿›ç‚¹æ€»è§ˆ

### ğŸ”´ æ ¸å¿ƒæ¶æ„æ”¹è¿›ï¼ˆå†³å®šæ™ºèƒ½æ°´å¹³ï¼‰

| åºå· | æ”¹è¿›ç‚¹ | ç´§æ€¥åº¦ | å¤æ‚åº¦ | é¢„è®¡å·¥æœŸ |
|------|--------|--------|--------|---------|
| 1 | æ¨ç†æ¨¡å¼ï¼šä»Plan-Executeå‡çº§åˆ°ReAct | ğŸ”´æé«˜ | é«˜ | 2-4å‘¨ |
| 2 | åŠ¨æ€é‡è§„åˆ’ï¼šå¤±è´¥åè‡ªåŠ¨è°ƒæ•´ç­–ç•¥ | ğŸ”´æé«˜ | ä¸­ | 1-2å‘¨ |
| 3 | æ€ç»´é€æ˜åº¦ï¼šå¯è§çš„reasoningè¿‡ç¨‹ | ğŸ”´é«˜ | ä½ | 1å‘¨ |
| 4 | å·¥å…·åŠ¨æ€é€‰æ‹©ï¼šæ ¹æ®ä»»åŠ¡æ™ºèƒ½ç­›é€‰ | ğŸ”´é«˜ | ä¸­ | 1-2å‘¨ |

### ğŸŸ¡ è‡ªä¸»è¡Œä¸ºèƒ½åŠ›ï¼ˆä»è¢«åŠ¨åˆ°ä¸»åŠ¨ï¼‰

| åºå· | æ”¹è¿›ç‚¹ | ç´§æ€¥åº¦ | å¤æ‚åº¦ | é¢„è®¡å·¥æœŸ |
|------|--------|--------|--------|---------|
| 5 | Heartbeatæœºåˆ¶ï¼šå‘¨æœŸæ€§è‡ªä¸»æ£€æŸ¥ | ğŸŸ¡ä¸­ | ä¸­ | 1-2å‘¨ |
| 6 | Cronå®šæ—¶ä»»åŠ¡ï¼šè‡ªåŠ¨ç”ŸæˆæŠ¥å‘Š | ğŸŸ¡ä¸­ | ä½ | 1å‘¨ |
| 7 | Hookäº‹ä»¶ç³»ç»Ÿï¼šäº‹ä»¶é©±åŠ¨çš„è‡ªåŠ¨åŒ– | ğŸŸ¡ä¸­ | é«˜ | 2-3å‘¨ |
| 8 | ä¸»åŠ¨æ¾„æ¸…ï¼šä¸ç¡®å®šæ—¶è¯¢é—®ç”¨æˆ· | ğŸŸ¡ä¸­ | ä¸­ | 1å‘¨ |

### ğŸŸ¢ äº¤äº’ä½“éªŒä¼˜åŒ–ï¼ˆç”¨æˆ·æ„ŸçŸ¥ï¼‰

| åºå· | æ”¹è¿›ç‚¹ | ç´§æ€¥åº¦ | å¤æ‚åº¦ | é¢„è®¡å·¥æœŸ |
|------|--------|--------|--------|---------|
| 9 | ä¸­æ–­ä¸æ¢å¤ï¼šç”¨æˆ·å¯æ§çš„æ‰§è¡Œ | ğŸŸ¢ä¸­ | ä¸­ | 1-2å‘¨ |
| 10 | è¿›åº¦åé¦ˆï¼šè¯¦ç»†çš„æ‰§è¡ŒçŠ¶æ€ | ğŸŸ¢ä¸­ | ä½ | 3-5å¤© |
| 11 | ç»“æœæ ¼å¼åŒ–ï¼šæ™ºèƒ½çš„è¾“å‡ºé€‚é… | ğŸŸ¢ä½ | ä½ | 3-5å¤© |
| 12 | å¯¹è¯å†å²ç®¡ç†ï¼šæ™ºèƒ½å‹ç¼©ä¸æ‘˜è¦ | ğŸŸ¢ä¸­ | ä¸­ | 1å‘¨ |

### ğŸ”µ å·¥å…·ç³»ç»Ÿå¢å¼ºï¼ˆèƒ½åŠ›æ‰©å±•ï¼‰

| åºå· | æ”¹è¿›ç‚¹ | ç´§æ€¥åº¦ | å¤æ‚åº¦ | é¢„è®¡å·¥æœŸ |
|------|--------|--------|--------|---------|
| 13 | å·¥å…·ç»„åˆèƒ½åŠ›ï¼šå¤åˆå·¥å…·è‡ªåŠ¨ç”Ÿæˆ | ğŸ”µä½ | é«˜ | 2å‘¨ |
| 14 | å·¥å…·ç»“æœç¼“å­˜ï¼šé¿å…é‡å¤è°ƒç”¨ | ğŸ”µä¸­ | ä½ | 3-5å¤© |
| 15 | å·¥å…·æƒé™ç­–ç•¥ï¼šç»†ç²’åº¦è®¿é—®æ§åˆ¶ | ğŸ”µä¸­ | ä¸­ | 1å‘¨ |
| 16 | å·¥å…·ä½¿ç”¨å­¦ä¹ ï¼šåŸºäºå†å²ä¼˜åŒ–é€‰æ‹© | ğŸ”µä½ | é«˜ | 2-3å‘¨ |

### âšª è®°å¿†ç³»ç»Ÿä¼˜åŒ–ï¼ˆæ‚¨å·²é¢†å…ˆï¼‰

| åºå· | æ”¹è¿›ç‚¹ | ç´§æ€¥åº¦ | å¤æ‚åº¦ | é¢„è®¡å·¥æœŸ |
|------|--------|--------|--------|---------|
| 17 | è®°å¿†é‡è¦æ€§è¯„åˆ†ï¼šæ™ºèƒ½æ·˜æ±°ç­–ç•¥ | âšªä½ | ä¸­ | 1å‘¨ |
| 18 | è·¨ä¼šè¯ç»éªŒè¿ç§»ï¼šä»“åº“é—´çŸ¥è¯†å…±äº« | âšªä½ | é«˜ | 2å‘¨ |
| 19 | è®°å¿†ä¸»åŠ¨å¬å›ï¼šé¢„æµ‹æ€§åŠ è½½ | âšªä½ | ä¸­ | 1å‘¨ |

---

## æ”¹è¿›ç‚¹ #1ï¼šæ¨ç†æ¨¡å¼å‡çº§ï¼ˆPlan-Execute â†’ ReActï¼‰

### ğŸ”´ ç´§æ€¥åº¦ï¼šæé«˜ | å¤æ‚åº¦ï¼šé«˜ | é¢„è®¡å·¥æœŸï¼š2-4å‘¨

---

### 1.1 å½“å‰çŠ¶æ€åˆ†æ

**æ‚¨çš„å®ç°ï¼ˆPlan-Executeæ¨¡å¼ï¼‰**ï¼š

```python
# å½“å‰å·¥ä½œæµ
context_node â†’ understand_node â†’ plan_node â†’ step_node(å¾ªç¯) â†’ synthesize_node

# plan_node ç”Ÿæˆå›ºå®šçš„æ‰§è¡Œè®¡åˆ’
execution_plan = {
    "goal": "åˆ†æç“¶é¢ˆ",
    "steps": [
        {"id": "1", "action": "query", "tool": "get_stages"},
        {"id": "2", "action": "query", "tool": "get_stage_status", "args": {"stage": "åˆ†æ‹£"}},
        {"id": "3", "action": "synthesize"}
    ],
    "max_steps": 5
}

# step_node æœºæ¢°æ‰§è¡Œ
for step in steps:
    result = execute_tool(step.tool, step.args)
    intermediate_results.append(result)
```

**é—®é¢˜**ï¼š
1. è®¡åˆ’åœ¨æ‰§è¡Œå‰å°±å›ºå®šï¼Œæ— æ³•æ ¹æ®ä¸­é—´ç»“æœè°ƒæ•´
2. step_nodeæ˜¯"æ‰§è¡Œè€…"è€Œé"æ€è€ƒè€…"
3. ç¼ºä¹åé¦ˆå¾ªç¯ï¼Œæ‰§è¡Œç»“æœä¸å½±å“åç»­å†³ç­–
4. é‡åˆ°æ„å¤–æƒ…å†µï¼ˆæ•°æ®ç¼ºå¤±ã€å·¥å…·å¤±è´¥ï¼‰æ— æ³•è‡ªé€‚åº”

### 1.2 Moltbotçš„åšæ³•ï¼ˆReActæ¨¡å¼ï¼‰

```typescript
// Pi Agentçš„ReActå¾ªç¯
async function runReActLoop(prompt: string) {
    const maxIterations = 50;  // å…è®¸æœ€å¤š50è½®æ€è€ƒ-è¡ŒåŠ¨
    
    for (let i = 0; i < maxIterations; i++) {
        // 1. THOUGHT: æ¨¡å‹æ€è€ƒå½“å‰çŠ¶æ€
        const response = await model.generate({
            messages: [...history, prompt],
            tools: availableTools
        });
        
        // 2. æ£€æŸ¥æ˜¯å¦å®Œæˆ
        if (response.isComplete) {
            return response.finalAnswer;
        }
        
        // 3. ACTION: å¦‚æœéœ€è¦è¡ŒåŠ¨
        if (response.toolCalls) {
            for (const call of response.toolCalls) {
                // 4. OBSERVATION: æ‰§è¡Œå¹¶è§‚å¯Ÿç»“æœ
                const result = await executeTool(call.name, call.args);
                
                // 5. å°†è§‚å¯ŸåŠ å…¥å†å²ï¼Œä¾›ä¸‹æ¬¡æ€è€ƒ
                history.push({
                    role: "tool",
                    content: result
                });
            }
        }
        
        // ç»§ç»­ä¸‹ä¸€è½®æ€è€ƒï¼ˆä¼šçœ‹åˆ°ä¸Šä¸€æ­¥çš„ç»“æœï¼‰
    }
}
```

**å…³é”®ç‰¹ç‚¹**ï¼š
- æ¯ä¸€è½®éƒ½é‡æ–°æ€è€ƒï¼Œæ ¹æ®æœ€æ–°è§‚å¯Ÿå†³å®šä¸‹ä¸€æ­¥
- æ²¡æœ‰é¢„å…ˆå›ºå®šçš„è®¡åˆ’ï¼Œå®Œå…¨åŠ¨æ€
- å…è®¸å¤šè¾¾50è½®è¿­ä»£ï¼Œå¤æ‚ä»»åŠ¡æœ‰è¶³å¤Ÿç©ºé—´
- é‡åˆ°æ„å¤–å¯ä»¥è‡ªåŠ¨è°ƒæ•´ç­–ç•¥

### 1.3 å·®è·åˆ†æ

| ç»´åº¦ | æ‚¨çš„å®ç° | Moltbot | å·®è· |
|------|---------|---------|------|
| å†³ç­–æ—¶æœº | æ‰§è¡Œå‰ä¸€æ¬¡æ€§è§„åˆ’ | æ¯æ­¥åŠ¨æ€å†³ç­– | ğŸ”´ æ ¸å¿ƒå·®è· |
| çµæ´»æ€§ | å›ºå®šæ­¥éª¤ | å®Œå…¨åŠ¨æ€ | ğŸ”´ æ ¸å¿ƒå·®è· |
| æœ€å¤§æ­¥éª¤ | 5æ­¥ | 50è½® | ğŸŸ¡ é™åˆ¶è¾ƒå¤§ |
| é”™è¯¯å¤„ç† | é‡è¯•åŒä¸€æ“ä½œ | æ¢ä¸ªæ–¹æ³•ç»§ç»­ | ğŸ”´ æ ¸å¿ƒå·®è· |
| æ„å¤–å¤„ç† | æŒ‰è®¡åˆ’ç»§ç»­ | é‡æ–°è¯„ä¼° | ğŸ”´ æ ¸å¿ƒå·®è· |

### 1.4 å…·ä½“æ”¹è¿›æ–¹æ¡ˆ

**æ–¹æ¡ˆï¼šæ··åˆReActæ¶æ„**

ä¿ç•™æ‚¨çš„åŒè·¯å¾„è®¾è®¡ä¼˜åŠ¿ï¼Œå°†Complexè·¯å¾„å‡çº§ä¸ºReActï¼š

```python
# æ–°çš„å·¥ä½œæµ
# Standardè·¯å¾„ä¿æŒä¸å˜ï¼ˆç®€å•é—®é¢˜å¿«é€Ÿå“åº”ï¼‰
# Complexè·¯å¾„æ”¹ä¸ºReActå¾ªç¯

# æ–°å¢èŠ‚ç‚¹
workflow.add_node("react_loop", react_loop_node)

# è·¯ç”±
def route_complexity(state):
    if state["understanding"]["complexity"] == "complex":
        return "react_loop"  # è¿›å…¥ReActå¾ªç¯
    return "reason_node"  # Standardè·¯å¾„ä¿æŒ
```

**æ ¸å¿ƒä»£ç ç»“æ„**ï¼š

```python
# app/agent/react/react_loop_node.py

from typing import TypedDict, Literal, Optional, List
from langchain_core.messages import AIMessage
from langgraph.config import get_stream_writer

class ThoughtResult(TypedDict):
    """æ€è€ƒç»“æœ"""
    reasoning: str  # æ¨ç†è¿‡ç¨‹
    decision: Literal["need_action", "final_answer", "clarify", "stuck"]
    next_action: Optional[dict]  # {"tool_name": "...", "tool_args": {...}, "reason": "..."}
    final_answer: Optional[str]
    clarification_question: Optional[str]

class Observation(TypedDict):
    """è§‚å¯Ÿè®°å½•"""
    iteration: int
    thought: str
    action: str
    action_args: dict
    result: any
    error: Optional[str]

async def react_loop_node(state: ConversationState, *, runtime) -> dict:
    """
    ReActå¾ªç¯èŠ‚ç‚¹ - æ›¿ä»£ plan_node + step_node + synthesize_node
    
    æ ¸å¿ƒå¾ªç¯ï¼šThought â†’ Action â†’ Observation â†’ Thought â†’ ...
    """
    
    # é…ç½®
    MAX_ITERATIONS = 15  # æ¯”Moltbotä¿å®ˆï¼Œä½†æ¯”åŸæ¥çš„5æ­¥å¤šå¾ˆå¤š
    
    # åˆå§‹åŒ–
    writer = get_stream_writer()
    understanding = state.get("understanding", {})
    enriched_context = state.get("enriched_context", {})
    user_memory = state.get("user_memory_context", {})
    
    # ç›®æ ‡
    goal = understanding.get("high_level_goal", "å›ç­”ç”¨æˆ·é—®é¢˜")
    user_message = state["messages"][-1].content
    
    # è·å–å·¥å…·
    available_tools = runtime.tools or []
    tool_map = {t.name: t for t in available_tools}
    tool_descriptions = [f"- {t.name}: {t.description}" for t in available_tools]
    
    # è§‚å¯Ÿè®°å½•
    observations: List[Observation] = []
    
    # === ReAct å¾ªç¯ ===
    for iteration in range(1, MAX_ITERATIONS + 1):
        
        # --- THOUGHT é˜¶æ®µ ---
        thought = await _generate_thought(
            goal=goal,
            user_message=user_message,
            observations=observations,
            enriched_context=enriched_context,
            user_memory=user_memory,
            tool_descriptions=tool_descriptions,
            iteration=iteration,
            max_iterations=MAX_ITERATIONS,
            model=runtime.model
        )
        
        # è¾“å‡ºæ€è€ƒè¿‡ç¨‹ï¼ˆé€æ˜åº¦ï¼‰
        writer({
            "type": "thinking",
            "iteration": iteration,
            "content": thought["reasoning"],
            "decision": thought["decision"]
        })
        
        # --- å†³ç­–åˆ†æ”¯ ---
        
        if thought["decision"] == "final_answer":
            # å·²ç»å¯ä»¥å›ç­”
            return {
                "messages": [AIMessage(content=thought["final_answer"])]
            }
        
        if thought["decision"] == "clarify":
            # éœ€è¦ç”¨æˆ·æ¾„æ¸…
            return {
                "messages": [AIMessage(content=thought["clarification_question"])],
                "awaiting_clarification": True
            }
        
        if thought["decision"] == "stuck":
            # æ— æ³•ç»§ç»­
            summary = _summarize_attempts(observations)
            return {
                "messages": [AIMessage(
                    content=f"æŠ±æ­‰ï¼Œæˆ‘å°è¯•äº†å¤šç§æ–¹æ³•ä½†æ— æ³•å®Œæˆä»»åŠ¡ã€‚\n\nå·²å°è¯•ï¼š\n{summary}"
                )]
            }
        
        if thought["decision"] == "need_action":
            # --- ACTION é˜¶æ®µ ---
            action = thought["next_action"]
            tool_name = action["tool_name"]
            tool_args = action.get("tool_args", {})
            
            writer({
                "type": "action",
                "iteration": iteration,
                "tool": tool_name,
                "args": tool_args,
                "reason": action.get("reason", "")
            })
            
            # æ‰§è¡Œå·¥å…·
            try:
                tool = tool_map.get(tool_name)
                if not tool:
                    raise ValueError(f"å·¥å…· {tool_name} ä¸å­˜åœ¨")
                
                result = await tool.ainvoke(tool_args)
                
                # --- OBSERVATION é˜¶æ®µ ---
                observations.append({
                    "iteration": iteration,
                    "thought": thought["reasoning"],
                    "action": tool_name,
                    "action_args": tool_args,
                    "result": result,
                    "error": None
                })
                
                writer({
                    "type": "observation",
                    "iteration": iteration,
                    "success": True,
                    "summary": _summarize_result(result)
                })
                
            except Exception as e:
                # é”™è¯¯ä¹Ÿæ˜¯ä¸€ç§è§‚å¯Ÿ
                error_str = str(e)
                
                observations.append({
                    "iteration": iteration,
                    "thought": thought["reasoning"],
                    "action": tool_name,
                    "action_args": tool_args,
                    "result": None,
                    "error": error_str
                })
                
                writer({
                    "type": "observation",
                    "iteration": iteration,
                    "success": False,
                    "error": error_str
                })
                
                # ä¸æŠ›å‡ºå¼‚å¸¸ï¼Œè®©ä¸‹ä¸€è½®æ€è€ƒå¤„ç†
    
    # è¶…è¿‡æœ€å¤§è¿­ä»£ï¼Œå¼ºåˆ¶æ€»ç»“
    final_answer = await _force_summarize(observations, goal, user_message, runtime.model)
    
    return {
        "messages": [AIMessage(content=final_answer)]
    }


async def _generate_thought(
    goal: str,
    user_message: str,
    observations: List[Observation],
    enriched_context: dict,
    user_memory: dict,
    tool_descriptions: List[str],
    iteration: int,
    max_iterations: int,
    model
) -> ThoughtResult:
    """
    ç”Ÿæˆæ€è€ƒ - ReActçš„æ ¸å¿ƒ
    """
    
    # æ ¼å¼åŒ–å†å²è§‚å¯Ÿ
    obs_text = _format_observations(observations)
    
    # æ„å»ºæç¤ºè¯
    prompt = f"""ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ä»“åº“åˆ†æåŠ©æ‰‹ï¼Œæ­£åœ¨å¸®åŠ©ç”¨æˆ·å®Œæˆä»»åŠ¡ã€‚

## ç”¨æˆ·åŸå§‹é—®é¢˜
{user_message}

## ä»»åŠ¡ç›®æ ‡
{goal}

## å½“å‰è¿›åº¦
ç¬¬ {iteration} è½®æ€è€ƒï¼Œæœ€å¤š {max_iterations} è½®

## å·²æœ‰çš„è§‚å¯Ÿç»“æœ
{obs_text if obs_text else "æš‚æ— ï¼Œè¿™æ˜¯ç¬¬ä¸€è½®"}

## å¯ç”¨å·¥å…·
{chr(10).join(tool_descriptions)}

## ç”¨æˆ·åå¥½ï¼ˆå¦‚æœ‰ï¼‰
{_format_user_memory(user_memory)}

---

è¯·è¿›è¡Œä¸‹ä¸€æ­¥æ€è€ƒï¼š

**æ€è€ƒæ¡†æ¶**ï¼š
1. æˆ‘ç°åœ¨çŸ¥é“äº†ä»€ä¹ˆï¼Ÿï¼ˆåŸºäºå·²æœ‰è§‚å¯Ÿï¼‰
2. æˆ‘è¿˜éœ€è¦äº†è§£ä»€ä¹ˆæ‰èƒ½å›ç­”ç”¨æˆ·ï¼Ÿ
3. ä¸‹ä¸€æ­¥åº”è¯¥æ€ä¹ˆåšï¼Ÿ

**å†³ç­–é€‰é¡¹**ï¼š
- `need_action`ï¼šéœ€è¦è°ƒç”¨å·¥å…·è·å–æ›´å¤šä¿¡æ¯
- `final_answer`ï¼šå·²æœ‰è¶³å¤Ÿä¿¡æ¯ï¼Œå¯ä»¥ç»™å‡ºæœ€ç»ˆç­”æ¡ˆ
- `clarify`ï¼šé—®é¢˜ä¸æ¸…æ¥šï¼Œéœ€è¦ç”¨æˆ·æ¾„æ¸…
- `stuck`ï¼šå°è¯•å¤šæ¬¡åä»æ— æ³•å®Œæˆ

**æ³¨æ„**ï¼š
- å¦‚æœä¸Šä¸€æ­¥å·¥å…·è°ƒç”¨å¤±è´¥äº†ï¼Œè€ƒè™‘æ¢ä¸€ç§æ–¹æ³•
- å¦‚æœæ•°æ®ä¸å­˜åœ¨ï¼Œè€ƒè™‘æ˜¯å¦æœ‰æ›¿ä»£æ•°æ®æº
- é¿å…é‡å¤è°ƒç”¨ç›¸åŒçš„å·¥å…·å’Œå‚æ•°

è¯·ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹JSONæ ¼å¼è¾“å‡ºï¼š

```json
{{
    "reasoning": "ä½ çš„æ€è€ƒè¿‡ç¨‹ï¼ˆ2-4å¥è¯ï¼Œè¯´æ˜åˆ¤æ–­ä¾æ®ï¼‰",
    "decision": "need_action | final_answer | clarify | stuck",
    "next_action": {{
        "tool_name": "å·¥å…·åç§°ï¼ˆä»…decisionä¸ºneed_actionæ—¶ï¼‰",
        "tool_args": {{}},
        "reason": "ä¸ºä»€ä¹ˆé€‰æ‹©è¿™ä¸ªå·¥å…·"
    }},
    "final_answer": "æœ€ç»ˆç­”æ¡ˆï¼ˆä»…decisionä¸ºfinal_answeræ—¶ï¼Œä½¿ç”¨Markdownæ ¼å¼ï¼‰",
    "clarification_question": "æ¾„æ¸…é—®é¢˜ï¼ˆä»…decisionä¸ºclarifyæ—¶ï¼‰"
}}
```"""

    # è°ƒç”¨æ¨¡å‹
    response = await model.with_structured_output(ThoughtResult).ainvoke(prompt)
    
    return response


def _format_observations(observations: List[Observation]) -> str:
    """æ ¼å¼åŒ–è§‚å¯Ÿå†å²"""
    if not observations:
        return ""
    
    lines = []
    for obs in observations:
        lines.append(f"### ç¬¬ {obs['iteration']} è½®")
        lines.append(f"**æ€è€ƒ**: {obs['thought']}")
        lines.append(f"**è¡ŒåŠ¨**: `{obs['action']}({obs['action_args']})`")
        
        if obs['error']:
            lines.append(f"**ç»“æœ**: âŒ å¤±è´¥ - {obs['error']}")
        else:
            summary = _summarize_result(obs['result'])
            lines.append(f"**ç»“æœ**: âœ… {summary}")
        
        lines.append("")
    
    return "\n".join(lines)


def _summarize_result(result) -> str:
    """ç®€æ´æ€»ç»“å·¥å…·ç»“æœ"""
    if result is None:
        return "æ— è¿”å›ç»“æœ"
    
    if isinstance(result, dict):
        if "data" in result:
            data = result["data"]
            if isinstance(data, list):
                return f"è¿”å›{len(data)}æ¡æ•°æ®è®°å½•"
            return f"è¿”å›æ•°æ®: {str(data)[:100]}..."
        
        keys = list(result.keys())[:5]
        return f"è¿”å›å­—å…¸ï¼ŒåŒ…å«å­—æ®µ: {', '.join(keys)}"
    
    if isinstance(result, list):
        return f"è¿”å›åˆ—è¡¨ï¼Œå…±{len(result)}é¡¹"
    
    result_str = str(result)
    if len(result_str) > 150:
        return result_str[:150] + "..."
    return result_str


def _format_user_memory(user_memory: dict) -> str:
    """æ ¼å¼åŒ–ç”¨æˆ·è®°å¿†"""
    if not user_memory:
        return "æ— "
    
    profile = user_memory.get("profile", {})
    prefs = profile.get("preferences", [])
    
    if prefs:
        return "\n".join([f"- {p.get('content', p)}" for p in prefs[:3]])
    
    return "æ— ç‰¹å®šåå¥½"


def _summarize_attempts(observations: List[Observation]) -> str:
    """æ€»ç»“å°è¯•è¿‡çš„æ–¹æ³•"""
    attempts = []
    for obs in observations:
        status = "âŒ" if obs["error"] else "âœ…"
        attempts.append(f"{status} {obs['action']}: {obs.get('error', 'æˆåŠŸä½†ä¿¡æ¯ä¸è¶³')}")
    
    return "\n".join(attempts)


async def _force_summarize(observations, goal, user_message, model) -> str:
    """è¶…æ—¶åå¼ºåˆ¶æ€»ç»“"""
    obs_text = _format_observations(observations)
    
    prompt = f"""ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ä»“åº“åˆ†æåŠ©æ‰‹ã€‚

ç”¨æˆ·é—®é¢˜ï¼š{user_message}
ä»»åŠ¡ç›®æ ‡ï¼š{goal}

ä½ å·²ç»æ‰§è¡Œäº†å¤šè½®å°è¯•ï¼Œä½†è¾¾åˆ°äº†æœ€å¤§è¿­ä»£æ¬¡æ•°ã€‚

å·²æœ‰çš„è§‚å¯Ÿç»“æœï¼š
{obs_text}

è¯·åŸºäºç°æœ‰ä¿¡æ¯ï¼Œå°½å¯èƒ½ç»™å‡ºæœ‰ä»·å€¼çš„å›ç­”ã€‚å¦‚æœä¿¡æ¯ä¸å®Œæ•´ï¼Œè¯·æ˜ç¡®è¯´æ˜å“ªäº›éƒ¨åˆ†æ— æ³•ç¡®å®šã€‚
"""
    
    response = await model.ainvoke(prompt)
    return response.content
```

### 1.5 å®æ–½æ­¥éª¤

**Step 1**: åˆ›å»ºReActèŠ‚ç‚¹ï¼ˆ2-3å¤©ï¼‰
- [ ] åˆ›å»º `app/agent/react/react_loop_node.py`
- [ ] å®ç° `_generate_thought` å‡½æ•°
- [ ] å®ç°è§‚å¯Ÿè®°å½•å’Œæ ¼å¼åŒ–

**Step 2**: å®šä¹‰æ•°æ®ç»“æ„ï¼ˆ1å¤©ï¼‰
- [ ] å®šä¹‰ `ThoughtResult` TypedDict
- [ ] å®šä¹‰ `Observation` TypedDict
- [ ] æ›´æ–° `ConversationState` æ·»åŠ  `observations` å­—æ®µ

**Step 3**: ä¿®æ”¹å·¥ä½œæµï¼ˆ1-2å¤©ï¼‰
- [ ] ä¿®æ”¹ `route_complexity` è·¯ç”±åˆ° `react_loop`
- [ ] ç§»é™¤å¯¹ `plan_node` å’Œ `step_node` çš„ä¾èµ–ï¼ˆComplexè·¯å¾„ï¼‰
- [ ] æ·»åŠ é‡è¯•ç­–ç•¥

**Step 4**: ä¼˜åŒ–æ€è€ƒè´¨é‡ï¼ˆ1å‘¨ï¼‰
- [ ] è°ƒä¼˜ `_generate_thought` çš„æç¤ºè¯
- [ ] æ·»åŠ few-shotç¤ºä¾‹
- [ ] æµ‹è¯•ä¸åŒåœºæ™¯

**Step 5**: æµ‹è¯•ä¸éªŒè¯ï¼ˆ3-5å¤©ï¼‰
- [ ] å•å…ƒæµ‹è¯•
- [ ] ä¸åŸå®ç°å¯¹æ¯”æµ‹è¯•
- [ ] è¾¹ç•Œæƒ…å†µæµ‹è¯•

### 1.6 é¢„æœŸæ•ˆæœ

| æŒ‡æ ‡ | æ”¹è¿›å‰ | æ”¹è¿›å |
|------|--------|--------|
| æ„å¤–æƒ…å†µå¤„ç† | æŒ‰è®¡åˆ’ç»§ç»­ï¼Œå¯èƒ½å¤±è´¥ | è‡ªåŠ¨è°ƒæ•´ç­–ç•¥ |
| å¤æ‚ä»»åŠ¡å®Œæˆç‡ | ~60% | ~85% |
| å¹³å‡æ€è€ƒæ­¥æ•° | å›ºå®š3-5æ­¥ | åŠ¨æ€2-15æ­¥ |
| ç”¨æˆ·æ»¡æ„åº¦ | ä¸­ç­‰ | æ˜¾è‘—æå‡ |

### 1.7 è®¨è®ºè¦ç‚¹

åœ¨å®æ–½å‰ï¼Œæˆ‘ä»¬éœ€è¦è®¨è®ºï¼š

1. **æœ€å¤§è¿­ä»£æ¬¡æ•°**ï¼šå»ºè®®15è½®ï¼Œæ‚¨è§‰å¾—åˆé€‚å—ï¼Ÿå¤ªå°‘å¯èƒ½é™åˆ¶å¤æ‚ä»»åŠ¡ï¼Œå¤ªå¤šå¯èƒ½å¯¼è‡´æ— é™å¾ªç¯ã€‚

2. **Standardè·¯å¾„æ˜¯å¦ä¿ç•™**ï¼šå»ºè®®ä¿ç•™ï¼Œç®€å•é—®é¢˜ç”¨Standardå¿«é€Ÿå“åº”ã€‚æ‚¨åŒæ„å—ï¼Ÿ

3. **æ€è€ƒé€æ˜åº¦çº§åˆ«**ï¼š
   - `full`ï¼šå®Œæ•´è¾“å‡ºæ‰€æœ‰æ€è€ƒ
   - `summary`ï¼šåªè¾“å‡ºå…³é”®å†³ç­–
   - `off`ï¼šä¸è¾“å‡ºæ€è€ƒ
   
   æ‚¨åå¥½å“ªç§ï¼Ÿ

4. **ä¸ç°æœ‰èŠ‚ç‚¹çš„å…¼å®¹**ï¼š
   - `understand_node` ä¿ç•™ï¼ˆè´Ÿè´£æ„å›¾è¯†åˆ«å’Œå¤æ‚åº¦åˆ¤æ–­ï¼‰
   - `context_node` ä¿ç•™ï¼ˆè´Ÿè´£ä¸Šä¸‹æ–‡æ„å»ºï¼‰
   - `plan_node`ã€`step_node`ã€`synthesize_node` æ›¿æ¢ä¸º `react_loop_node`
   
   è¿™ä¸ªæ–¹æ¡ˆå¯ä»¥æ¥å—å—ï¼Ÿ

---

## æ”¹è¿›ç‚¹ #2ï¼šåŠ¨æ€é‡è§„åˆ’èƒ½åŠ›

### ğŸ”´ ç´§æ€¥åº¦ï¼šæé«˜ | å¤æ‚åº¦ï¼šä¸­ | é¢„è®¡å·¥æœŸï¼š1-2å‘¨

---

### 2.1 å½“å‰çŠ¶æ€åˆ†æ

**æ‚¨çš„å®ç°**ï¼š

```python
# å½“å‰é”™è¯¯å¤„ç†
STEP_NODE_RETRY_POLICY = RetryPolicy(
    max_attempts=2,
    initial_interval=1.0,
    backoff_factor=2.0,
    jitter=True
)

# é—®é¢˜ï¼šåªæ˜¯é‡è¯•ç›¸åŒçš„æ“ä½œ
# å¦‚æœå·¥å…·å‚æ•°é”™è¯¯ã€æ•°æ®ä¸å­˜åœ¨ï¼Œé‡è¯•ä¹Ÿä¸ä¼šæˆåŠŸ
```

**å…¸å‹å¤±è´¥åœºæ™¯**ï¼š

```
ç”¨æˆ·ï¼š"åˆ†ææ­å·ä»“åˆ†æ‹£ç¯èŠ‚çš„æ•ˆç‡"

Step 1: get_stage_status(stage="åˆ†æ‹£")
ç»“æœï¼šâŒ é”™è¯¯ - "åˆ†æ‹£"ç¯èŠ‚ä¸å­˜åœ¨ï¼Œè¯·ä½¿ç”¨"sorting"

Step 2ï¼ˆé‡è¯•ï¼‰: get_stage_status(stage="åˆ†æ‹£")
ç»“æœï¼šâŒ ç›¸åŒé”™è¯¯

æœ€ç»ˆï¼šè¿”å›å¤±è´¥
```

### 2.2 Moltbotçš„åšæ³•

```typescript
// Pi Agentçš„é”™è¯¯å¤„ç†
// é”™è¯¯ä¼šä½œä¸ºè§‚å¯Ÿç»“æœè¿”å›ç»™æ¨¡å‹
// æ¨¡å‹åœ¨ä¸‹ä¸€è½®æ€è€ƒä¸­å¯ä»¥çœ‹åˆ°é”™è¯¯å¹¶è°ƒæ•´ç­–ç•¥

// ä¾‹å¦‚ï¼š
// Thought: ä¸Šä¸€æ­¥æŸ¥è¯¢"åˆ†æ‹£"å¤±è´¥ï¼Œé”™è¯¯è¯´åº”è¯¥ç”¨"sorting"ï¼Œè®©æˆ‘ä¿®æ­£å‚æ•°
// Action: get_stage_status(stage="sorting")
```

### 2.3 æ”¹è¿›æ–¹æ¡ˆ

**å¦‚æœæ‚¨å®æ–½äº†æ”¹è¿›ç‚¹#1ï¼ˆReActï¼‰**ï¼Œé‡è§„åˆ’èƒ½åŠ›å·²ç»å†…ç½®ã€‚

**å¦‚æœæš‚æ—¶ä¿ç•™Plan-Executeæ¨¡å¼**ï¼Œéœ€è¦å•ç‹¬å®ç°ï¼š

```python
# app/agent/recovery/replanning.py

class ReplanningStrategy:
    """
    é‡è§„åˆ’ç­–ç•¥ - å½“æ‰§è¡Œå¤±è´¥æ—¶é‡æ–°ç”Ÿæˆè®¡åˆ’
    """
    
    def __init__(self, model):
        self.model = model
    
    async def should_replan(
        self,
        error: Exception,
        step: PlanStep,
        execution_plan: ExecutionPlan
    ) -> bool:
        """åˆ¤æ–­æ˜¯å¦éœ€è¦é‡è§„åˆ’"""
        
        # åˆ†ç±»é”™è¯¯
        error_type = self._classify_error(error)
        
        # æš‚æ—¶æ€§é”™è¯¯ï¼ˆç½‘ç»œã€è¶…æ—¶ï¼‰â†’ é‡è¯•
        if error_type == "transient":
            return False
        
        # é€»è¾‘é”™è¯¯ï¼ˆå‚æ•°é”™è¯¯ã€èµ„æºä¸å­˜åœ¨ï¼‰â†’ é‡è§„åˆ’
        if error_type == "logical":
            return True
        
        # è‡´å‘½é”™è¯¯ â†’ ä¸é‡è§„åˆ’ï¼Œç›´æ¥æŠ¥å‘Š
        if error_type == "fatal":
            return False
        
        return True  # æœªçŸ¥é”™è¯¯é»˜è®¤å°è¯•é‡è§„åˆ’
    
    async def replan(
        self,
        error: Exception,
        failed_step: PlanStep,
        execution_plan: ExecutionPlan,
        completed_results: List[IntermediateResult]
    ) -> ExecutionPlan:
        """
        ç”Ÿæˆæ–°è®¡åˆ’
        """
        
        prompt = f"""
åŸè®¡åˆ’æ‰§è¡Œå¤±è´¥ï¼Œéœ€è¦é‡æ–°è§„åˆ’ã€‚

## åŸå§‹ç›®æ ‡
{execution_plan['goal']}

## å·²å®Œæˆçš„æ­¥éª¤
{self._format_completed(completed_results)}

## å¤±è´¥çš„æ­¥éª¤
å·¥å…·: {failed_step['tool_name']}
å‚æ•°: {failed_step.get('tool_args', {})}
é”™è¯¯: {str(error)}

## å¯ç”¨å·¥å…·
{self._format_tools()}

è¯·ç”Ÿæˆæ–°çš„æ‰§è¡Œè®¡åˆ’ï¼Œé¿å…ä¹‹å‰çš„é”™è¯¯ã€‚
è€ƒè™‘ï¼š
1. æ˜¯å¦éœ€è¦ä¿®æ”¹å‚æ•°ï¼Ÿ
2. æ˜¯å¦éœ€è¦æ¢ä¸€ä¸ªå·¥å…·ï¼Ÿ
3. æ˜¯å¦éœ€è¦å…ˆæŸ¥è¯¢å…¶ä»–ä¿¡æ¯ï¼Ÿ

è¾“å‡ºæ–°çš„ExecutionPlan JSONã€‚
"""
        
        new_plan = await self.model.with_structured_output(ExecutionPlan).ainvoke(prompt)
        
        # ä¿ç•™å·²å®Œæˆçš„ç»“æœ
        new_plan['completed_results'] = completed_results
        
        return new_plan
    
    def _classify_error(self, error: Exception) -> str:
        """åˆ†ç±»é”™è¯¯"""
        error_str = str(error).lower()
        
        if any(kw in error_str for kw in ["timeout", "connection", "rate limit"]):
            return "transient"
        
        if any(kw in error_str for kw in ["not found", "invalid", "does not exist", "å‚æ•°"]):
            return "logical"
        
        if any(kw in error_str for kw in ["authentication", "permission", "forbidden"]):
            return "fatal"
        
        return "unknown"
```

**åœ¨step_nodeä¸­ä½¿ç”¨**ï¼š

```python
async def step_node_with_replanning(state, *, runtime):
    replanning = ReplanningStrategy(runtime.model)
    max_replans = 3
    replan_count = 0
    
    while replan_count < max_replans:
        try:
            # æ‰§è¡Œå½“å‰æ­¥éª¤
            result = await execute_step(state, runtime)
            return result
        
        except Exception as e:
            if await replanning.should_replan(e, current_step, execution_plan):
                replan_count += 1
                
                # é‡æ–°è§„åˆ’
                new_plan = await replanning.replan(
                    error=e,
                    failed_step=current_step,
                    execution_plan=execution_plan,
                    completed_results=state.get("intermediate_results", [])
                )
                
                # æ›´æ–°çŠ¶æ€
                state["execution_plan"] = new_plan
                
                # é€šçŸ¥ç”¨æˆ·
                writer({
                    "type": "replanning",
                    "reason": str(e),
                    "new_approach": new_plan.get("steps", [{}])[0].get("description")
                })
                
                continue
            else:
                raise  # ä¸èƒ½é‡è§„åˆ’çš„é”™è¯¯ç›´æ¥æŠ›å‡º
    
    # è¶…è¿‡é‡è§„åˆ’æ¬¡æ•°
    return {"error": "å¤šæ¬¡å°è¯•åä»æ— æ³•å®Œæˆ"}
```

### 2.4 å®æ–½æ­¥éª¤

**Step 1**: å®ç°é”™è¯¯åˆ†ç±»ï¼ˆ1å¤©ï¼‰
- [ ] åˆ›å»º `ErrorClassifier` ç±»
- [ ] å®šä¹‰é”™è¯¯ç±»å‹æšä¸¾
- [ ] æµ‹è¯•å„ç§é”™è¯¯çš„åˆ†ç±»

**Step 2**: å®ç°é‡è§„åˆ’é€»è¾‘ï¼ˆ2-3å¤©ï¼‰
- [ ] åˆ›å»º `ReplanningStrategy` ç±»
- [ ] å®ç° `should_replan` æ–¹æ³•
- [ ] å®ç° `replan` æ–¹æ³•

**Step 3**: é›†æˆåˆ°å·¥ä½œæµï¼ˆ1-2å¤©ï¼‰
- [ ] ä¿®æ”¹ `step_node` æ·»åŠ é‡è§„åˆ’æ”¯æŒ
- [ ] æ·»åŠ é‡è§„åˆ’æ¬¡æ•°é™åˆ¶
- [ ] æ·»åŠ ç”¨æˆ·é€šçŸ¥

**Step 4**: æµ‹è¯•ï¼ˆ2-3å¤©ï¼‰
- [ ] æ¨¡æ‹Ÿå„ç§é”™è¯¯åœºæ™¯
- [ ] éªŒè¯é‡è§„åˆ’æ•ˆæœ
- [ ] è¾¹ç•Œæƒ…å†µæµ‹è¯•

### 2.5 è®¨è®ºè¦ç‚¹

1. **é‡è§„åˆ’æ¬¡æ•°é™åˆ¶**ï¼šå»ºè®®æœ€å¤š3æ¬¡ï¼Œæ‚¨è§‰å¾—åˆé€‚å—ï¼Ÿ

2. **æ˜¯å¦ä¸ReActä¸€èµ·å®æ–½**ï¼šå¦‚æœå®æ–½æ”¹è¿›ç‚¹#1ï¼Œè¿™ä¸ªå¯ä»¥ç®€åŒ–ç”šè‡³è·³è¿‡ã€‚æ‚¨çš„ä¼˜å…ˆçº§æ˜¯ä»€ä¹ˆï¼Ÿ

3. **é”™è¯¯åˆ†ç±»è§„åˆ™**ï¼šå½“å‰çš„åˆ†ç±»è§„åˆ™æ˜¯å¦ç¬¦åˆæ‚¨çš„ä¸šåŠ¡åœºæ™¯ï¼Ÿéœ€è¦è°ƒæ•´å—ï¼Ÿ

---

## æ”¹è¿›ç‚¹ #3ï¼šæ€ç»´é€æ˜åº¦

### ğŸ”´ ç´§æ€¥åº¦ï¼šé«˜ | å¤æ‚åº¦ï¼šä½ | é¢„è®¡å·¥æœŸï¼š1å‘¨

---

### 3.1 å½“å‰çŠ¶æ€åˆ†æ

**æ‚¨çš„å®ç°**ï¼š

```python
# å½“å‰æµå¼è¾“å‡º
writer({
    "type": "progress",
    "step": "analyzing",
    "message": "æ­£åœ¨åˆ†ææ•°æ®..."
})

# é—®é¢˜ï¼šç”¨æˆ·åªçœ‹åˆ°"æ­£åœ¨åˆ†æ"ï¼Œä¸çŸ¥é“Agentåœ¨æƒ³ä»€ä¹ˆ
```

### 3.2 Moltbotçš„åšæ³•

```
ç”¨æˆ·é—®é¢˜
    â†“
<thinking>
ç”¨æˆ·æƒ³çŸ¥é“ä»“åº“ç“¶é¢ˆï¼Œæˆ‘éœ€è¦ï¼š
1. å…ˆè·å–æ‰€æœ‰ç¯èŠ‚çš„çŠ¶æ€
2. å¯¹æ¯”æ­£å¸¸æ°´å¹³
3. æ‰¾å‡ºå¼‚å¸¸ç¯èŠ‚
è®©æˆ‘å…ˆè°ƒç”¨get_warehouse_stages...
</thinking>

è°ƒç”¨å·¥å…·: get_warehouse_stages
ç»“æœ: [åˆ†æ‹£, ä¸Šæ¶, æ‰“åŒ…, å‘è´§]

<thinking>
å¾—åˆ°äº†4ä¸ªç¯èŠ‚ï¼Œç°åœ¨éœ€è¦æŸ¥çœ‹æ¯ä¸ªç¯èŠ‚çš„æ•ˆç‡ã€‚
åˆ†æ‹£ç¯èŠ‚çš„å®æ—¶æ•°æ®ä¼¼ä¹æœ‰é—®é¢˜ï¼Œè®©æˆ‘æ·±å…¥çœ‹çœ‹...
</thinking>

è°ƒç”¨å·¥å…·: get_stage_status("åˆ†æ‹£")
...
```

### 3.3 æ”¹è¿›æ–¹æ¡ˆ

```python
# app/agent/transparency/thinking_stream.py

from enum import Enum
from typing import Optional
from langgraph.config import get_stream_writer

class ThinkingMode(Enum):
    FULL = "full"        # å®Œæ•´è¾“å‡ºæ‰€æœ‰æ€è€ƒ
    SUMMARY = "summary"  # è¾“å‡ºç®€åŒ–ç‰ˆ
    OFF = "off"          # ä¸è¾“å‡ºæ€è€ƒ

class ThinkingStream:
    """
    æ€ç»´æµè¾“å‡ºå™¨
    
    è®©ç”¨æˆ·çœ‹åˆ°Agentçš„æ¨ç†è¿‡ç¨‹
    """
    
    def __init__(self, mode: ThinkingMode = ThinkingMode.SUMMARY):
        self.mode = mode
        self.writer = get_stream_writer()
    
    def emit_thinking(
        self,
        content: str,
        stage: str = "reasoning",
        iteration: Optional[int] = None
    ):
        """è¾“å‡ºæ€è€ƒå†…å®¹"""
        
        if self.mode == ThinkingMode.OFF:
            return
        
        if self.mode == ThinkingMode.SUMMARY:
            # æå–å…³é”®å¥å­
            content = self._extract_key_points(content)
        
        self.writer({
            "type": "thinking",
            "stage": stage,
            "iteration": iteration,
            "content": content,
            "timestamp": datetime.now().isoformat()
        })
    
    def emit_decision(self, decision: str, reason: str):
        """è¾“å‡ºå†³ç­–"""
        self.writer({
            "type": "decision",
            "decision": decision,
            "reason": reason
        })
    
    def emit_action(self, tool_name: str, reason: str, args: dict = None):
        """è¾“å‡ºè¡ŒåŠ¨"""
        self.writer({
            "type": "action",
            "tool": tool_name,
            "reason": reason,
            "args": args
        })
    
    def emit_observation(self, success: bool, summary: str, details: any = None):
        """è¾“å‡ºè§‚å¯Ÿç»“æœ"""
        self.writer({
            "type": "observation",
            "success": success,
            "summary": summary,
            "details": details if self.mode == ThinkingMode.FULL else None
        })
    
    def emit_progress(self, message: str, percentage: Optional[int] = None):
        """è¾“å‡ºè¿›åº¦"""
        self.writer({
            "type": "progress",
            "message": message,
            "percentage": percentage
        })
    
    def _extract_key_points(self, content: str) -> str:
        """æå–å…³é”®ç‚¹ï¼ˆç®€åŒ–ç‰ˆï¼‰"""
        # æå–åŒ…å«å…³é”®è¯çš„å¥å­
        keywords = ["å› æ­¤", "æ‰€ä»¥", "éœ€è¦", "å‘ç°", "æ¥ä¸‹æ¥", "å†³å®š", "è®¤ä¸º"]
        
        sentences = content.split("ã€‚")
        key_sentences = [
            s for s in sentences
            if any(kw in s for kw in keywords)
        ]
        
        if key_sentences:
            return "ã€‚".join(key_sentences[:2]) + "ã€‚"
        
        # å¦‚æœæ²¡æœ‰å…³é”®è¯ï¼Œè¿”å›å‰100å­—
        return content[:100] + "..." if len(content) > 100 else content
```

**å‰ç«¯å±•ç¤ºæ•ˆæœ**ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ’­ æ€è€ƒä¸­...                                                â”‚
â”‚                                                             â”‚
â”‚  "ç”¨æˆ·æƒ³åˆ†æç“¶é¢ˆï¼Œæˆ‘éœ€è¦å…ˆè·å–å„ç¯èŠ‚çŠ¶æ€..."                  â”‚
â”‚                                                             â”‚
â”‚  ğŸ”§ è°ƒç”¨å·¥å…·: get_warehouse_stages                           â”‚
â”‚     åŸå› : è·å–ä»“åº“çš„æ‰€æœ‰ä½œä¸šç¯èŠ‚                             â”‚
â”‚                                                             â”‚
â”‚  ğŸ“Š ç»“æœ: è¿”å›4ä¸ªç¯èŠ‚ï¼ˆåˆ†æ‹£ã€ä¸Šæ¶ã€æ‰“åŒ…ã€å‘è´§ï¼‰              â”‚
â”‚                                                             â”‚
â”‚  ğŸ’­ "åˆ†æ‹£ç¯èŠ‚æ•ˆç‡åä½ï¼Œéœ€è¦æ·±å…¥åˆ†æ..."                       â”‚
â”‚                                                             â”‚
â”‚  ğŸ”§ è°ƒç”¨å·¥å…·: get_stage_status                               â”‚
â”‚     å‚æ•°: stage="åˆ†æ‹£"                                       â”‚
â”‚                                                             â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 60% â”â”â”â”â”â”â”â”â”â”                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.4 å®æ–½æ­¥éª¤

**Step 1**: åˆ›å»ºThinkingStreamç±»ï¼ˆ1å¤©ï¼‰
- [ ] å®ç°åŸºç¡€ç±»
- [ ] å®ç°ä¸‰ç§æ¨¡å¼
- [ ] å®ç°å…³é”®ç‚¹æå–

**Step 2**: é›†æˆåˆ°èŠ‚ç‚¹ï¼ˆ2å¤©ï¼‰
- [ ] åœ¨ `react_loop_node` / `reason_node` ä¸­ä½¿ç”¨
- [ ] åœ¨ `step_node` ä¸­ä½¿ç”¨
- [ ] ç»Ÿä¸€è¾“å‡ºæ ¼å¼

**Step 3**: å‰ç«¯é€‚é…ï¼ˆ2-3å¤©ï¼‰
- [ ] æ›´æ–°SSEè§£æ
- [ ] å®ç°æ€è€ƒæ¡†UI
- [ ] æ·»åŠ å±•å¼€/æŠ˜å 

### 3.5 è®¨è®ºè¦ç‚¹

1. **é»˜è®¤æ¨¡å¼**ï¼šå»ºè®®é»˜è®¤ `SUMMARY`ï¼Œæ‚¨åå¥½å“ªç§ï¼Ÿ

2. **æ˜¯å¦éœ€è¦é…ç½®**ï¼šæ˜¯å¦å…è®¸ç”¨æˆ·é€‰æ‹©é€æ˜åº¦çº§åˆ«ï¼Ÿ

3. **æ€§èƒ½å½±å“**ï¼šå®Œæ•´æ¨¡å¼ä¼šå¢åŠ è¾“å‡ºé‡ï¼Œæ˜¯å¦éœ€è¦é™åˆ¶ï¼Ÿ

---

## æ”¹è¿›ç‚¹ #4ï¼šå·¥å…·åŠ¨æ€é€‰æ‹©

### ğŸ”´ ç´§æ€¥åº¦ï¼šé«˜ | å¤æ‚åº¦ï¼šä¸­ | é¢„è®¡å·¥æœŸï¼š1-2å‘¨

---

### 4.1 å½“å‰çŠ¶æ€åˆ†æ

**æ‚¨çš„å®ç°**ï¼š

```python
# å½“å‰ï¼šæ‰€æœ‰å·¥å…·éƒ½ä¼ ç»™æ¨¡å‹
tools = [
    query_orders_data,           # æ•°æ®æŸ¥è¯¢
    get_warehouse_info,          # ä»“åº“ä¿¡æ¯
    get_stage_status,            # ç¯èŠ‚çŠ¶æ€
    detect_anomalies,            # å¼‚å¸¸æ£€æµ‹
    execute_cypher,              # å›¾æ•°æ®åº“
    ...                          # å…±22ä¸ªå·¥å…·
]

# é—®é¢˜ï¼š
# 1. å·¥å…·å¤ªå¤šï¼Œæ¨¡å‹é€‰æ‹©å›°éš¾
# 2. æ— å…³å·¥å…·å¹²æ‰°åˆ¤æ–­
# 3. Tokenæ¶ˆè€—å¤§
```

### 4.2 æ”¹è¿›æ–¹æ¡ˆ

```python
# app/agent/tools/dynamic_selector.py

class DynamicToolSelector:
    """
    åŠ¨æ€å·¥å…·é€‰æ‹©å™¨
    
    æ ¹æ®ä»»åŠ¡ç‰¹å¾é€‰æ‹©ç›¸å…³å·¥å…·å­é›†
    """
    
    def __init__(self, all_tools: List[BaseTool]):
        self.all_tools = {t.name: t for t in all_tools}
        
        # å·¥å…·èƒ½åŠ›æ ‡ç­¾
        self.tool_capabilities = {
            "query_orders_data": ["data_query", "statistics", "historical"],
            "get_warehouse_info": ["basic_info", "metadata"],
            "get_stage_status": ["realtime_status", "monitoring"],
            "get_warehouse_stages": ["structure", "overview"],
            "detect_anomalies": ["anomaly_detection", "alerting"],
            "get_team_state": ["team", "workforce"],
            "execute_cypher": ["advanced_query", "graph"],
            # ... å…¶ä»–å·¥å…·
        }
        
        # ä»»åŠ¡-èƒ½åŠ›æ˜ å°„
        self.task_capability_map = {
            "query_data": ["data_query", "statistics"],
            "analyze_trend": ["data_query", "historical", "statistics"],
            "compare": ["data_query", "historical"],
            "optimize": ["realtime_status", "anomaly_detection", "team"],
            "general_qa": ["basic_info", "overview"],
            "monitor": ["realtime_status", "monitoring", "alerting"],
        }
    
    def select_tools(
        self,
        intent: str,
        entities: dict,
        max_tools: int = 10
    ) -> List[BaseTool]:
        """
        æ ¹æ®æ„å›¾å’Œå®ä½“é€‰æ‹©å·¥å…·
        """
        
        # 1. è·å–æ‰€éœ€èƒ½åŠ›
        required_capabilities = self.task_capability_map.get(intent, [])
        
        # 2. åŒ¹é…å·¥å…·
        matched_tools = []
        for tool_name, capabilities in self.tool_capabilities.items():
            if any(cap in capabilities for cap in required_capabilities):
                matched_tools.append(self.all_tools[tool_name])
        
        # 3. æ ¹æ®å®ä½“è¿›ä¸€æ­¥ç­›é€‰
        if "ç¯èŠ‚" in str(entities) or "stage" in str(entities):
            # æ·»åŠ ç¯èŠ‚ç›¸å…³å·¥å…·
            stage_tools = ["get_stage_status", "get_warehouse_stages"]
            for name in stage_tools:
                if name in self.all_tools and self.all_tools[name] not in matched_tools:
                    matched_tools.append(self.all_tools[name])
        
        # 4. æ·»åŠ å¸¸ç”¨åŸºç¡€å·¥å…·
        essential_tools = ["get_warehouse_info", "query_orders_data"]
        for name in essential_tools:
            if name in self.all_tools and self.all_tools[name] not in matched_tools:
                matched_tools.append(self.all_tools[name])
        
        # 5. é™åˆ¶æ•°é‡
        return matched_tools[:max_tools]
    
    def get_tool_descriptions(self, tools: List[BaseTool]) -> str:
        """ç”Ÿæˆå·¥å…·æè¿°æ–‡æœ¬"""
        descriptions = []
        for tool in tools:
            descriptions.append(f"- **{tool.name}**: {tool.description}")
        
        return "\n".join(descriptions)
```

**åœ¨ä¸Šä¸‹æ–‡èŠ‚ç‚¹ä½¿ç”¨**ï¼š

```python
# context_node ä¸­
async def context_node(state, *, runtime):
    understanding = state.get("understanding", {})
    
    # åŠ¨æ€é€‰æ‹©å·¥å…·
    selector = DynamicToolSelector(runtime.tools)
    selected_tools = selector.select_tools(
        intent=understanding.get("intent", "general_qa"),
        entities=understanding.get("entities", {}),
        max_tools=10
    )
    
    # æ›´æ–°å¯ç”¨å·¥å…·
    runtime.tools = selected_tools
    
    # ç”Ÿæˆå·¥å…·æè¿°ä¾›åç»­èŠ‚ç‚¹ä½¿ç”¨
    enriched_context["available_tools"] = [t.name for t in selected_tools]
    enriched_context["tool_descriptions"] = selector.get_tool_descriptions(selected_tools)
    
    return {"enriched_context": enriched_context}
```

### 4.3 å®æ–½æ­¥éª¤

**Step 1**: æ ‡æ³¨å·¥å…·èƒ½åŠ›ï¼ˆ1å¤©ï¼‰
- [ ] ä¸ºæ‰€æœ‰22ä¸ªå·¥å…·æ ‡æ³¨èƒ½åŠ›æ ‡ç­¾
- [ ] å®šä¹‰ä»»åŠ¡-èƒ½åŠ›æ˜ å°„

**Step 2**: å®ç°é€‰æ‹©å™¨ï¼ˆ2å¤©ï¼‰
- [ ] åˆ›å»º `DynamicToolSelector` ç±»
- [ ] å®ç°å¤šç»´åº¦åŒ¹é…
- [ ] æµ‹è¯•é€‰æ‹©å‡†ç¡®ç‡

**Step 3**: é›†æˆåˆ°å·¥ä½œæµï¼ˆ1-2å¤©ï¼‰
- [ ] ä¿®æ”¹ `context_node`
- [ ] ç¡®ä¿å·¥å…·åˆ—è¡¨åŠ¨æ€ä¼ é€’

### 4.4 è®¨è®ºè¦ç‚¹

1. **å·¥å…·èƒ½åŠ›æ ‡ç­¾**ï¼šéœ€è¦æ‚¨å¸®åŠ©ç¡®è®¤22ä¸ªå·¥å…·çš„èƒ½åŠ›æ ‡ç­¾æ˜¯å¦å‡†ç¡®ã€‚

2. **é€‰æ‹©ç­–ç•¥**ï¼šæ˜¯å¦éœ€è¦æ›´æ™ºèƒ½çš„é€‰æ‹©ï¼ˆå¦‚åŸºäºå†å²ä½¿ç”¨æ•°æ®ï¼‰ï¼Ÿ

3. **æœ€å¤§å·¥å…·æ•°**ï¼šå»ºè®®10ä¸ªï¼Œæ‚¨è§‰å¾—åˆé€‚å—ï¼Ÿ

---

## æ”¹è¿›ç‚¹ #5ï¼šHeartbeatæœºåˆ¶

### ğŸŸ¡ ç´§æ€¥åº¦ï¼šä¸­ | å¤æ‚åº¦ï¼šä¸­ | é¢„è®¡å·¥æœŸï¼š1-2å‘¨

---

### 5.1 å½“å‰çŠ¶æ€åˆ†æ

**æ‚¨çš„å®ç°**ï¼šå®Œå…¨è¢«åŠ¨ï¼Œåªåœ¨ç”¨æˆ·å‘é€æ¶ˆæ¯æ—¶å“åº”ã€‚

### 5.2 Moltbotçš„åšæ³•

```typescript
// Heartbeaté…ç½®
{
  "heartbeat": {
    "interval": "30m",        // æ¯30åˆ†é’Ÿ
    "quietHours": [22, 8],   // 22:00-08:00é™é»˜
    "checks": [
      "pending_tasks",        // æ£€æŸ¥å¾…å¤„ç†ä»»åŠ¡
      "anomaly_scan",         // å¼‚å¸¸æ‰«æ
      "scheduled_reports"     // å®šæœŸæŠ¥å‘Š
    ]
  }
}

// æ‰§è¡Œæµç¨‹
1. å®šæ—¶è§¦å‘
2. è¯»å–HEARTBEAT.mdï¼ˆæ£€æŸ¥æ¸…å•ï¼‰
3. æ‰§è¡ŒAgentè¿è¡Œ
4. å¦‚æœæœ‰é‡è¦äº‹é¡¹ â†’ å‘é€é€šçŸ¥
5. å¦‚æœæ— äº‹ â†’ é™é»˜ï¼ˆHEARTBEAT_OKï¼‰
```

### 5.3 æ”¹è¿›æ–¹æ¡ˆ

```python
# app/agent/autonomous/heartbeat.py

import asyncio
from datetime import datetime, time
from typing import List, Optional, Callable

class HeartbeatRunner:
    """
    å¿ƒè·³è¿è¡Œå™¨
    
    è®©Agentå®šæœŸè‡ªä¸»æ£€æŸ¥ï¼Œå‘ç°é—®é¢˜ä¸»åŠ¨é€šçŸ¥
    """
    
    def __init__(
        self,
        agent,
        interval_minutes: int = 30,
        quiet_hours: tuple = (22, 8),
        notification_callback: Callable = None
    ):
        self.agent = agent
        self.interval = interval_minutes * 60
        self.quiet_start, self.quiet_end = quiet_hours
        self.notification_callback = notification_callback
        self.running = False
        self.checks = []
    
    def register_check(self, name: str, check_func: Callable, priority: int = 0):
        """æ³¨å†Œæ£€æŸ¥é¡¹"""
        self.checks.append({
            "name": name,
            "func": check_func,
            "priority": priority
        })
        self.checks.sort(key=lambda x: x["priority"], reverse=True)
    
    async def start(self):
        """å¯åŠ¨å¿ƒè·³"""
        self.running = True
        
        while self.running:
            await asyncio.sleep(self.interval)
            
            if self._is_quiet_hours():
                continue
            
            await self._run_heartbeat()
    
    def stop(self):
        """åœæ­¢å¿ƒè·³"""
        self.running = False
    
    async def _run_heartbeat(self):
        """æ‰§è¡Œå¿ƒè·³æ£€æŸ¥"""
        important_items = []
        
        for check in self.checks:
            try:
                result = await check["func"](self.agent)
                
                if result and result.get("is_important"):
                    important_items.append({
                        "check": check["name"],
                        "message": result.get("message"),
                        "severity": result.get("severity", "info"),
                        "data": result.get("data")
                    })
            
            except Exception as e:
                # æ£€æŸ¥å¤±è´¥ä¸å½±å“å…¶ä»–æ£€æŸ¥
                print(f"Heartbeat check {check['name']} failed: {e}")
        
        if important_items and self.notification_callback:
            await self.notification_callback(important_items)
    
    def _is_quiet_hours(self) -> bool:
        """æ˜¯å¦åœ¨é™é»˜æ—¶æ®µ"""
        now = datetime.now().hour
        
        if self.quiet_start > self.quiet_end:
            # è·¨åˆå¤œï¼ˆå¦‚22-8ï¼‰
            return now >= self.quiet_start or now < self.quiet_end
        else:
            return self.quiet_start <= now < self.quiet_end


# é¢„å®šä¹‰çš„æ£€æŸ¥å‡½æ•°
async def check_anomalies(agent) -> Optional[dict]:
    """æ£€æŸ¥å¼‚å¸¸æŒ‡æ ‡"""
    # è·å–ç”¨æˆ·ç®¡ç†çš„ä»“åº“
    warehouses = await agent.get_user_warehouses()
    
    all_anomalies = []
    for wh in warehouses:
        result = await agent.execute_tool(
            "detect_stage_anomalies",
            {"warehouse_code": wh}
        )
        
        if result.get("anomalies"):
            all_anomalies.extend(result["anomalies"])
    
    if all_anomalies:
        return {
            "is_important": True,
            "message": f"æ£€æµ‹åˆ°{len(all_anomalies)}ä¸ªå¼‚å¸¸æŒ‡æ ‡",
            "severity": "warning",
            "data": all_anomalies
        }
    
    return None

async def check_pending_tasks(agent) -> Optional[dict]:
    """æ£€æŸ¥å¾…å¤„ç†ä»»åŠ¡"""
    # ä»ç”¨æˆ·è®°å¿†ä¸­è·å–å¾…å¤„ç†ä»»åŠ¡
    tasks = await agent.get_pending_tasks()
    
    overdue = [t for t in tasks if t.get("due_at") and t["due_at"] < datetime.now()]
    
    if overdue:
        return {
            "is_important": True,
            "message": f"æœ‰{len(overdue)}ä¸ªä»»åŠ¡å·²è¿‡æœŸ",
            "severity": "warning",
            "data": overdue
        }
    
    return None

async def check_scheduled_reports(agent) -> Optional[dict]:
    """æ£€æŸ¥æ˜¯å¦éœ€è¦ç”ŸæˆæŠ¥å‘Š"""
    # æ£€æŸ¥æ˜¯å¦åˆ°äº†æŠ¥å‘Šæ—¶é—´
    now = datetime.now()
    
    # æ¯å¤©9ç‚¹çš„æ—¥æŠ¥
    if now.hour == 9 and now.minute < 30:
        return {
            "is_important": True,
            "message": "æ—¥æŠ¥ç”Ÿæˆæ—¶é—´åˆ°",
            "severity": "info",
            "data": {"report_type": "daily"}
        }
    
    # æ¯å‘¨äº”17ç‚¹çš„å‘¨æŠ¥
    if now.weekday() == 4 and now.hour == 17 and now.minute < 30:
        return {
            "is_important": True,
            "message": "å‘¨æŠ¥ç”Ÿæˆæ—¶é—´åˆ°",
            "severity": "info",
            "data": {"report_type": "weekly"}
        }
    
    return None


# ä½¿ç”¨ç¤ºä¾‹
heartbeat = HeartbeatRunner(
    agent=agent,
    interval_minutes=30,
    quiet_hours=(22, 8),
    notification_callback=send_notification
)

# æ³¨å†Œæ£€æŸ¥é¡¹
heartbeat.register_check("anomalies", check_anomalies, priority=10)
heartbeat.register_check("pending_tasks", check_pending_tasks, priority=5)
heartbeat.register_check("scheduled_reports", check_scheduled_reports, priority=1)

# å¯åŠ¨
asyncio.create_task(heartbeat.start())
```

### 5.4 å®æ–½æ­¥éª¤

**Step 1**: å®ç°HeartbeatRunnerï¼ˆ2-3å¤©ï¼‰
- [ ] åˆ›å»ºåŸºç¡€ç±»
- [ ] å®ç°å®šæ—¶æœºåˆ¶
- [ ] å®ç°é™é»˜æ—¶æ®µ

**Step 2**: å®ç°æ£€æŸ¥å‡½æ•°ï¼ˆ2-3å¤©ï¼‰
- [ ] å¼‚å¸¸æ£€æŸ¥
- [ ] å¾…å¤„ç†ä»»åŠ¡æ£€æŸ¥
- [ ] æŠ¥å‘Šæ—¶é—´æ£€æŸ¥

**Step 3**: é›†æˆé€šçŸ¥ï¼ˆ2å¤©ï¼‰
- [ ] å®ç°é€šçŸ¥å›è°ƒ
- [ ] æ ¼å¼åŒ–é€šçŸ¥å†…å®¹
- [ ] æµ‹è¯•é€šçŸ¥å‘é€

### 5.5 è®¨è®ºè¦ç‚¹

1. **æ£€æŸ¥é—´éš”**ï¼šå»ºè®®30åˆ†é’Ÿï¼Œæ‚¨è§‰å¾—åˆé€‚å—ï¼Ÿ

2. **é™é»˜æ—¶æ®µ**ï¼š22:00-08:00æ˜¯å¦ç¬¦åˆæ‚¨çš„ä¸šåŠ¡åœºæ™¯ï¼Ÿ

3. **æ£€æŸ¥é¡¹ä¼˜å…ˆçº§**ï¼šå“ªäº›æ£€æŸ¥æ›´é‡è¦ï¼Ÿ

4. **é€šçŸ¥æ–¹å¼**ï¼šå¦‚ä½•é€šçŸ¥ç”¨æˆ·ï¼Ÿï¼ˆAPIæ¨é€ï¼Ÿæ¶ˆæ¯é˜Ÿåˆ—ï¼Ÿï¼‰

---

## æ”¹è¿›ç‚¹ #6ï¼šCronå®šæ—¶ä»»åŠ¡

### ğŸŸ¡ ç´§æ€¥åº¦ï¼šä¸­ | å¤æ‚åº¦ï¼šä½ | é¢„è®¡å·¥æœŸï¼š1å‘¨

---

### 6.1 æ”¹è¿›æ–¹æ¡ˆ

```python
# app/agent/autonomous/cron.py

from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger

class CronScheduler:
    """
    å®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨
    
    æ”¯æŒï¼š
    - Cronè¡¨è¾¾å¼
    - å›ºå®šé—´éš”
    - ä¸€æ¬¡æ€§ä»»åŠ¡
    """
    
    def __init__(self, agent):
        self.agent = agent
        self.scheduler = AsyncIOScheduler()
        self.jobs = {}
    
    def add_cron_job(
        self,
        job_id: str,
        cron_expr: str,
        handler: Callable,
        kwargs: dict = None
    ):
        """
        æ·»åŠ Cronä»»åŠ¡
        
        cron_expr: æ ‡å‡†Cronè¡¨è¾¾å¼ï¼Œå¦‚ "0 9 * * *" è¡¨ç¤ºæ¯å¤©9ç‚¹
        """
        trigger = CronTrigger.from_crontab(cron_expr)
        
        job = self.scheduler.add_job(
            handler,
            trigger,
            id=job_id,
            kwargs={"agent": self.agent, **(kwargs or {})}
        )
        
        self.jobs[job_id] = job
    
    def add_interval_job(
        self,
        job_id: str,
        hours: int = 0,
        minutes: int = 0,
        handler: Callable = None,
        kwargs: dict = None
    ):
        """æ·»åŠ å›ºå®šé—´éš”ä»»åŠ¡"""
        job = self.scheduler.add_job(
            handler,
            'interval',
            hours=hours,
            minutes=minutes,
            id=job_id,
            kwargs={"agent": self.agent, **(kwargs or {})}
        )
        
        self.jobs[job_id] = job
    
    def start(self):
        """å¯åŠ¨è°ƒåº¦å™¨"""
        self.scheduler.start()
    
    def stop(self):
        """åœæ­¢è°ƒåº¦å™¨"""
        self.scheduler.shutdown()


# é¢„å®šä¹‰ä»»åŠ¡
async def generate_daily_report(agent, **kwargs):
    """ç”Ÿæˆæ—¥æŠ¥"""
    warehouses = kwargs.get("warehouses", [])
    
    report = await agent.invoke({
        "type": "report",
        "report_type": "daily",
        "warehouses": warehouses
    })
    
    # å‘é€æŠ¥å‘Š
    await agent.send_notification({
        "title": "ğŸ“Š æ¯æ—¥æŠ¥å‘Š",
        "content": report,
        "timestamp": datetime.now()
    })

async def generate_weekly_report(agent, **kwargs):
    """ç”Ÿæˆå‘¨æŠ¥"""
    # ç±»ä¼¼å®ç°
    pass

async def run_anomaly_scan(agent, **kwargs):
    """å¼‚å¸¸æ‰«æ"""
    # ç±»ä¼¼å®ç°
    pass


# ä½¿ç”¨ç¤ºä¾‹
scheduler = CronScheduler(agent)

# æ¯å¤©9ç‚¹ç”Ÿæˆæ—¥æŠ¥
scheduler.add_cron_job(
    "daily_report",
    "0 9 * * *",
    generate_daily_report,
    {"warehouses": ["HZ001", "SH001"]}
)

# æ¯å‘¨äº”17ç‚¹ç”Ÿæˆå‘¨æŠ¥
scheduler.add_cron_job(
    "weekly_report",
    "0 17 * * 5",
    generate_weekly_report
)

# æ¯å°æ—¶å¼‚å¸¸æ‰«æ
scheduler.add_interval_job(
    "anomaly_scan",
    hours=1,
    handler=run_anomaly_scan
)

scheduler.start()
```

### 6.2 è®¨è®ºè¦ç‚¹

1. **ä½¿ç”¨APSchedulerè¿˜æ˜¯è‡ªå®ç°**ï¼šAPScheduleræ›´æˆç†Ÿï¼Œè‡ªå®ç°æ›´å¯æ§ã€‚æ‚¨åå¥½å“ªä¸ªï¼Ÿ

2. **ä»»åŠ¡æŒä¹…åŒ–**ï¼šä»»åŠ¡é…ç½®æ˜¯å¦éœ€è¦æŒä¹…åŒ–åˆ°æ•°æ®åº“ï¼Ÿ

3. **å…·ä½“éœ€è¦å“ªäº›å®šæ—¶ä»»åŠ¡**ï¼š
   - æ—¥æŠ¥ï¼ˆæ¯å¤©å‡ ç‚¹ï¼Ÿï¼‰
   - å‘¨æŠ¥ï¼ˆæ¯å‘¨å‡ ï¼Ÿï¼‰
   - å¼‚å¸¸æ‰«æï¼ˆé—´éš”å¤šä¹…ï¼Ÿï¼‰
   - å…¶ä»–ï¼Ÿ

---

## æ”¹è¿›ç‚¹ #7ï¼šHookäº‹ä»¶ç³»ç»Ÿ

### ğŸŸ¡ ç´§æ€¥åº¦ï¼šä¸­ | å¤æ‚åº¦ï¼šé«˜ | é¢„è®¡å·¥æœŸï¼š2-3å‘¨

---

### 7.1 æ”¹è¿›æ–¹æ¡ˆ

```python
# app/agent/hooks/registry.py

from typing import Callable, Dict, List
from enum import Enum

class HookType(Enum):
    # ä¼šè¯ç”Ÿå‘½å‘¨æœŸ
    SESSION_START = "session:start"
    SESSION_END = "session:end"
    
    # Agentç”Ÿå‘½å‘¨æœŸ
    AGENT_BEFORE_RUN = "agent:before_run"
    AGENT_AFTER_RUN = "agent:after_run"
    
    # å·¥å…·è°ƒç”¨
    TOOL_BEFORE_CALL = "tool:before_call"
    TOOL_AFTER_CALL = "tool:after_call"
    TOOL_ERROR = "tool:error"
    
    # æ•°æ®äº‹ä»¶
    DATA_ANOMALY = "data:anomaly"
    DATA_THRESHOLD_EXCEEDED = "data:threshold_exceeded"
    
    # å®šæ—¶äº‹ä»¶
    SCHEDULE_DAILY_REPORT = "schedule:daily_report"
    SCHEDULE_WEEKLY_REPORT = "schedule:weekly_report"

class HookRegistry:
    """
    Hookæ³¨å†Œè¡¨
    
    æ”¯æŒäº‹ä»¶é©±åŠ¨çš„æ‰©å±•ç‚¹
    """
    
    def __init__(self):
        self.hooks: Dict[str, List[Callable]] = {}
    
    def register(self, event_type: str, handler: Callable, priority: int = 0):
        """æ³¨å†ŒHook"""
        if event_type not in self.hooks:
            self.hooks[event_type] = []
        
        self.hooks[event_type].append({
            "handler": handler,
            "priority": priority
        })
        
        # æŒ‰ä¼˜å…ˆçº§æ’åº
        self.hooks[event_type].sort(key=lambda x: x["priority"], reverse=True)
    
    async def trigger(self, event_type: str, event_data: dict) -> List[any]:
        """è§¦å‘Hook"""
        handlers = self.hooks.get(event_type, [])
        results = []
        
        for h in handlers:
            try:
                result = await h["handler"](event_data)
                results.append(result)
            except Exception as e:
                print(f"Hook error [{event_type}]: {e}")
                # é”™è¯¯ä¸å½±å“å…¶ä»–handler
        
        return results
    
    def unregister(self, event_type: str, handler: Callable):
        """æ³¨é”€Hook"""
        if event_type in self.hooks:
            self.hooks[event_type] = [
                h for h in self.hooks[event_type]
                if h["handler"] != handler
            ]

# è£…é¥°å™¨è¯­æ³•
def hook(event_type: str, priority: int = 0):
    """Hookè£…é¥°å™¨"""
    def decorator(func):
        registry.register(event_type, func, priority)
        return func
    return decorator

# å…¨å±€æ³¨å†Œè¡¨
registry = HookRegistry()


# ä½¿ç”¨ç¤ºä¾‹
@hook("session:start", priority=10)
async def on_session_start(event):
    """ä¼šè¯å¼€å§‹æ—¶åŠ è½½ç”¨æˆ·ä¸Šä¸‹æ–‡"""
    user_id = event.get("user_id")
    # é¢„åŠ è½½ç”¨æˆ·æ•°æ®
    await preload_user_context(user_id)

@hook("tool:after_call")
async def log_tool_usage(event):
    """è®°å½•å·¥å…·ä½¿ç”¨"""
    await record_tool_usage(
        tool_name=event.get("tool_name"),
        args=event.get("args"),
        result=event.get("result"),
        user_id=event.get("user_id")
    )

@hook("data:anomaly")
async def on_anomaly_detected(event):
    """å¼‚å¸¸æ£€æµ‹æ—¶è‡ªåŠ¨åˆ†æ"""
    anomaly = event.get("anomaly")
    
    # è§¦å‘Agentåˆ†æ
    analysis = await agent.analyze_anomaly(anomaly)
    
    # å‘é€é¢„è­¦
    await send_alert({
        "type": "anomaly",
        "data": anomaly,
        "analysis": analysis
    })
```

### 7.2 è®¨è®ºè¦ç‚¹

1. **éœ€è¦å“ªäº›Hookç‚¹**ï¼šä¸Šé¢åˆ—çš„æ˜¯å¦å¤Ÿç”¨ï¼Ÿéœ€è¦å¢å‡ï¼Ÿ

2. **Hookæ‰§è¡Œæ¨¡å¼**ï¼š
   - å¹¶è¡Œæ‰§è¡Œï¼ˆfire-and-forgetï¼‰
   - é¡ºåºæ‰§è¡Œï¼ˆå‰ä¸€ä¸ªå®Œæˆæ‰æ‰§è¡Œä¸‹ä¸€ä¸ªï¼‰
   æ‚¨åå¥½å“ªç§ï¼Ÿ

3. **Hooké…ç½®æ–¹å¼**ï¼šä»£ç æ³¨å†Œè¿˜æ˜¯é…ç½®æ–‡ä»¶ï¼Ÿ

---

## æ”¹è¿›ç‚¹ #8ï¼šä¸»åŠ¨æ¾„æ¸…èƒ½åŠ›

### ğŸŸ¡ ç´§æ€¥åº¦ï¼šä¸­ | å¤æ‚åº¦ï¼šä¸­ | é¢„è®¡å·¥æœŸï¼š1å‘¨

---

### 8.1 æ”¹è¿›æ–¹æ¡ˆ

```python
# åœ¨ReActå¾ªç¯ä¸­

class ThoughtResult(TypedDict):
    # ...
    decision: Literal["need_action", "final_answer", "clarify", "stuck"]
    clarification_question: Optional[str]  # å½“decision=clarifyæ—¶

# è§¦å‘æ¾„æ¸…çš„åœºæ™¯
"""
1. é—®é¢˜æ­§ä¹‰
   ç”¨æˆ·ï¼š"åˆ†æä¸€ä¸‹æ•°æ®"
   Agentï¼š"æ‚¨å¸Œæœ›åˆ†æå“ªä¸ªä»“åº“çš„ä»€ä¹ˆæ•°æ®ï¼Ÿæ—¶é—´èŒƒå›´æ˜¯ï¼Ÿ"

2. å…³é”®ä¿¡æ¯ç¼ºå¤±
   ç”¨æˆ·ï¼š"å¯¹æ¯”æ•ˆç‡"
   Agentï¼š"è¯·é—®æ‚¨æƒ³å¯¹æ¯”å“ªä¸¤ä¸ªç¯èŠ‚/æ—¶æ®µçš„æ•ˆç‡ï¼Ÿ"

3. å¤šç§ç†è§£å¯èƒ½
   ç”¨æˆ·ï¼š"çœ‹çœ‹æ­å·çš„æƒ…å†µ"
   Agentï¼š"æ‚¨æ˜¯æƒ³çœ‹æ­å·ä»“çš„å®æ—¶çŠ¶æ€ï¼Œè¿˜æ˜¯å†å²æ•°æ®åˆ†æï¼Ÿ"
"""

# æ¾„æ¸…æç¤ºè¯
CLARIFY_PROMPT = """
å½“å‰ä¿¡æ¯ä¸è¶³ä»¥å‡†ç¡®å›ç­”ç”¨æˆ·é—®é¢˜ã€‚

ç”¨æˆ·é—®é¢˜ï¼š{user_message}
å·²çŸ¥ä¿¡æ¯ï¼š{known_info}
ç¼ºå¤±ä¿¡æ¯ï¼š{missing_info}

è¯·ç”Ÿæˆä¸€ä¸ªç®€æ´çš„æ¾„æ¸…é—®é¢˜ï¼Œå¸®åŠ©ç”¨æˆ·è¡¥å……ä¿¡æ¯ã€‚
è¦æ±‚ï¼š
1. é—®é¢˜è¦å…·ä½“ï¼Œæœ€å¥½æä¾›é€‰é¡¹
2. ä¸è¦ä¸€æ¬¡é—®å¤ªå¤š
3. è¯­æ°”å‹å¥½

è¾“å‡ºæ¾„æ¸…é—®é¢˜ï¼š
"""

# åœ¨_generate_thoughtä¸­æ£€æµ‹
async def _should_clarify(observations, user_message, entities) -> Optional[str]:
    """åˆ¤æ–­æ˜¯å¦éœ€è¦æ¾„æ¸…"""
    
    # æ£€æŸ¥å…³é”®å®ä½“æ˜¯å¦ç¼ºå¤±
    required_entities = {
        "query_data": ["warehouse", "date_range"],
        "analyze_trend": ["warehouse", "metric", "date_range"],
        "compare": ["subjects", "metric"],
    }
    
    intent = understanding.get("intent")
    required = required_entities.get(intent, [])
    
    missing = []
    for entity in required:
        if entity not in entities or not entities[entity]:
            missing.append(entity)
    
    if missing:
        return await _generate_clarification(user_message, entities, missing)
    
    return None
```

### 8.2 è®¨è®ºè¦ç‚¹

1. **ä½•æ—¶è§¦å‘æ¾„æ¸…**ï¼šå…³é”®ä¿¡æ¯ç¼ºå¤±ï¼Ÿè¿˜æ˜¯ä»»ä½•ä¸ç¡®å®šéƒ½é—®ï¼Ÿ

2. **æ¾„æ¸…æ¬¡æ•°é™åˆ¶**ï¼šæœ€å¤šé—®å‡ æ¬¡ï¼Ÿå»ºè®®2æ¬¡ã€‚

3. **ä¸understand_nodeçš„å…³ç³»**ï¼šæ¾„æ¸…é€»è¾‘æ”¾åœ¨å“ªé‡Œæ›´åˆé€‚ï¼Ÿ

---

## æ”¹è¿›ç‚¹ #9ï¼šä¸­æ–­ä¸æ¢å¤

### ğŸŸ¢ ç´§æ€¥åº¦ï¼šä¸­ | å¤æ‚åº¦ï¼šä¸­ | é¢„è®¡å·¥æœŸï¼š1-2å‘¨

---

### 9.1 æ”¹è¿›æ–¹æ¡ˆ

```python
# app/agent/control/interruptible.py

class InterruptibleExecution:
    """
    å¯ä¸­æ–­çš„æ‰§è¡Œ
    
    æ”¯æŒï¼š
    1. ç”¨æˆ·ä¸»åŠ¨ä¸­æ–­
    2. è¶…æ—¶è‡ªåŠ¨ä¸­æ–­
    3. ä»æ£€æŸ¥ç‚¹æ¢å¤
    """
    
    def __init__(self, agent, storage):
        self.agent = agent
        self.storage = storage
        self.abort_event = asyncio.Event()
        self.current_checkpoint = None
    
    async def run(self, state, runtime, timeout: int = 300):
        """å¯ä¸­æ–­çš„è¿è¡Œ"""
        
        # è®¾ç½®è¶…æ—¶
        try:
            result = await asyncio.wait_for(
                self._run_with_checkpoints(state, runtime),
                timeout=timeout
            )
            return result
        
        except asyncio.TimeoutError:
            # ä¿å­˜æ£€æŸ¥ç‚¹
            checkpoint_id = await self._save_checkpoint()
            return {
                "status": "timeout",
                "message": f"æ“ä½œè¶…æ—¶ï¼ˆ{timeout}ç§’ï¼‰ï¼Œå·²ä¿å­˜è¿›åº¦",
                "checkpoint_id": checkpoint_id,
                "can_resume": True
            }
        
        except InterruptedError:
            checkpoint_id = await self._save_checkpoint()
            return {
                "status": "interrupted",
                "message": "æ“ä½œå·²ä¸­æ–­ï¼Œå·²ä¿å­˜è¿›åº¦",
                "checkpoint_id": checkpoint_id,
                "can_resume": True
            }
    
    async def _run_with_checkpoints(self, state, runtime):
        """å¸¦æ£€æŸ¥ç‚¹çš„è¿è¡Œ"""
        
        async for chunk in self.agent.astream(state, runtime):
            # æ£€æŸ¥ä¸­æ–­
            if self.abort_event.is_set():
                raise InterruptedError()
            
            # å®šæœŸä¿å­˜æ£€æŸ¥ç‚¹
            if chunk.get("type") == "observation":
                self.current_checkpoint = {
                    "state": state,
                    "observations": chunk.get("observations"),
                    "timestamp": datetime.now()
                }
            
            yield chunk
    
    def abort(self):
        """ä¸­æ–­æ‰§è¡Œ"""
        self.abort_event.set()
    
    async def _save_checkpoint(self) -> str:
        """ä¿å­˜æ£€æŸ¥ç‚¹"""
        if not self.current_checkpoint:
            return None
        
        checkpoint_id = str(uuid.uuid4())
        
        await self.storage.save({
            "id": checkpoint_id,
            **self.current_checkpoint,
            "expires_at": datetime.now() + timedelta(hours=1)
        })
        
        return checkpoint_id
    
    async def resume(self, checkpoint_id: str):
        """ä»æ£€æŸ¥ç‚¹æ¢å¤"""
        checkpoint = await self.storage.load(checkpoint_id)
        
        if not checkpoint:
            raise ValueError("æ£€æŸ¥ç‚¹ä¸å­˜åœ¨æˆ–å·²è¿‡æœŸ")
        
        # æ¢å¤çŠ¶æ€
        state = checkpoint["state"]
        state["observations"] = checkpoint["observations"]
        
        return await self.run(state, self.runtime)


# APIæ¥å£
@app.post("/chat")
async def chat(request: ChatRequest):
    execution = InterruptibleExecution(agent, storage)
    
    # ä¿å­˜æ‰§è¡Œå®ä¾‹ä¾›ä¸­æ–­ä½¿ç”¨
    executions[request.session_id] = execution
    
    return await execution.run(...)

@app.post("/chat/interrupt/{session_id}")
async def interrupt(session_id: str):
    execution = executions.get(session_id)
    if execution:
        execution.abort()
        return {"status": "interrupting"}
    return {"error": "Session not found"}

@app.post("/chat/resume/{checkpoint_id}")
async def resume(checkpoint_id: str):
    execution = InterruptibleExecution(agent, storage)
    return await execution.resume(checkpoint_id)
```

### 9.2 è®¨è®ºè¦ç‚¹

1. **è¶…æ—¶æ—¶é—´**ï¼šå»ºè®®5åˆ†é’Ÿï¼Œæ‚¨è§‰å¾—åˆé€‚å—ï¼Ÿ

2. **æ£€æŸ¥ç‚¹ä¿å­˜ç­–ç•¥**ï¼šæ¯æ¬¡è§‚å¯Ÿåä¿å­˜ï¼Ÿè¿˜æ˜¯å›ºå®šé—´éš”ï¼Ÿ

3. **æ£€æŸ¥ç‚¹è¿‡æœŸæ—¶é—´**ï¼šå»ºè®®1å°æ—¶ï¼Œæ‚¨è§‰å¾—åˆé€‚å—ï¼Ÿ

---

## æ”¹è¿›ç‚¹ #10-19ï¼šå…¶ä»–æ”¹è¿›ç‚¹

ç”±äºç¯‡å¹…é™åˆ¶ï¼Œä»¥ä¸‹æ”¹è¿›ç‚¹æˆ‘å°†æä¾›ç®€åŒ–ç‰ˆæœ¬ï¼Œå¦‚éœ€è¯¦ç»†å±•å¼€è¯·å‘ŠçŸ¥ï¼š

### #10 è¿›åº¦åé¦ˆä¼˜åŒ–
- æ·»åŠ é¢„ä¼°å®Œæˆæ—¶é—´
- æ›´ç»†ç²’åº¦çš„è¿›åº¦ç™¾åˆ†æ¯”
- å½“å‰æ­¥éª¤æè¿°

### #11 ç»“æœæ ¼å¼åŒ–
- æ ¹æ®æ•°æ®ç±»å‹è‡ªåŠ¨é€‰æ‹©å±•ç¤ºæ–¹å¼
- è¡¨æ ¼ã€å›¾è¡¨ã€åˆ—è¡¨æ™ºèƒ½åˆ‡æ¢
- ç”¨æˆ·åå¥½é€‚é…

### #12 å¯¹è¯å†å²ç®¡ç†
- æ™ºèƒ½å‹ç¼©ï¼ˆæ‘˜è¦æ›¿æ¢å†å²ï¼‰
- Tokenè®¡æ•°ç›‘æ§
- é‡è¦æ¶ˆæ¯æ ‡è®°ä¿æŠ¤

### #13 å·¥å…·ç»„åˆèƒ½åŠ›
- é¢„å®šä¹‰å¤åˆå·¥å…·
- åŠ¨æ€ç»„åˆç”Ÿæˆ
- ç»„åˆä¼˜åŒ–

### #14 å·¥å…·ç»“æœç¼“å­˜
- TTLç¼“å­˜
- å‚æ•°å“ˆå¸Œ
- ç¼“å­˜å‘½ä¸­ç»Ÿè®¡

### #15 å·¥å…·æƒé™ç­–ç•¥
- æŒ‰ç”¨æˆ·/ä»“åº“é…ç½®
- allowlist/denylist
- è¿è¡Œæ—¶æ£€æŸ¥

### #16 å·¥å…·ä½¿ç”¨å­¦ä¹ 
- ä½¿ç”¨é¢‘ç‡ç»Ÿè®¡
- æˆåŠŸç‡è¿½è¸ª
- æ¨èæ’åº

### #17 è®°å¿†é‡è¦æ€§è¯„åˆ†
- å¤šå› ç´ è¯„åˆ†
- LRUæ·˜æ±°
- æ‘˜è¦å‹ç¼©

### #18 è·¨ä»“åº“ç»éªŒè¿ç§»
- ç›¸ä¼¼åº¦è®¡ç®—
- å¯è¿ç§»è§„åˆ™æ ‡è®°
- ç½®ä¿¡åº¦è°ƒæ•´

### #19 è®°å¿†ä¸»åŠ¨å¬å›
- é¢„æµ‹æ€§åŠ è½½
- å…³é”®è¯è§¦å‘
- ç¼“å­˜é¢„çƒ­

---

## ğŸ“Œ ä¸‹ä¸€æ­¥è¡ŒåŠ¨

è¯·å‘Šè¯‰æˆ‘ï¼š

1. **æ‚¨æƒ³å…ˆè®¨è®ºå“ªä¸ªæ”¹è¿›ç‚¹ï¼Ÿ**ï¼ˆå»ºè®®ä» #1 ReAct å¼€å§‹ï¼‰

2. **æ¯ä¸ªæ”¹è¿›ç‚¹çš„è®¨è®ºæ·±åº¦**ï¼š
   - ç®€å•ç¡®è®¤æ–¹æ¡ˆ
   - è¯¦ç»†ä»£ç Review
   - å®é™…ç¼–ç å®æ–½

3. **æ—¶é—´å®‰æ’**ï¼š
   - æ¯å¤©è®¨è®ºå‡ ä¸ªç‚¹ï¼Ÿ
   - æ˜¯å¦éœ€è¦åˆ†æ‰¹æ¬¡ï¼Ÿ

æˆ‘ä»¬å¯ä»¥æŒ‰ç…§æ‚¨çš„èŠ‚å¥ï¼Œé€ä¸€æ·±å…¥è®¨è®ºå¹¶å®æ–½æ¯ä¸ªæ”¹è¿›ç‚¹ã€‚
